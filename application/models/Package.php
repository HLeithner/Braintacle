<?php
/**
 * Class representing a package which can be deployed to a computer
 *
 * Copyright (C) 2011-2014 Holger Schletz <holger.schletz@web.de>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * @package Models
 */
/** A single package which can be deployed to a computer
 *
 * This class provides an interface to all related database entries, the
 * download directory and the files stored within this directory (XML metafile
 * and the package fragments).
 *
 * The procedures of building and activating a package are merged into a single
 * step. This is limited to a single download location per package.
 *
 *
 * The following properties are mapped to a column in the download_available
 * table. Some of these will also be used in the XML metafile.
 *
 * - <b>Name:</b> name to uniquely identify package
 * - <b>Timestamp:</b> Timestamp of package creation
 * - <b>Priority:</b> download priority (0-10)
 * - <b>NumFragments:</b> number of download fragments - ignored by {@link build()}
 * - <b>Size:</b> download size - ignored by {@link build()}
 * - <b>Platform:</b> one of 'windows', 'linux' or 'mac'
 * - <b>Comment:</b> comment
 *
 * The following properties are mapped to a column in the download_enable table.
 *
 * - <b>EnabledId:</b> primary key for download_enable
 *
 * The following readonly properties are generated by {@link fetchAll()}.
 *
 * - <b>NumNonnotified:</b> number of clients waiting for notification
 * - <b>NumSuccess:</b> number of clients with successful deployment
 * - <b>NumNotified:</b> number of clients currently downloading/installing package
 * - <b>NumError:</b> number of clients with unsuccessful deployment
 *
 * The following properties are mapped to an XML attribute.
 *
 * - <b>Hash:</b> hash of assembled package
 * - <b>DeployAction:</b> one of 'store', 'execute', 'launch'
 * - <b>ActionParam:</b> path for storage or command to execute, depending on action
 * - <b>Warn:</b> Whether the user should be notified before deployment
 * - <b>WarnMessage:</b> Message to display before deployment
 * - <b>WarnCountdown:</b> Timeout in seconds before deployment starts
 * - <b>WarnAllowAbort:</b> Whether the user should be allowed to abort
 * - <b>WarnAllowDelay:</b> Whether the user should be allowed to delay
 * - <b>PostInstMessage:</b> Message to display after deployment
 *
 * The following Attributes are only used by {@link build()}.
 *
 * - <b>FileName:</b> name of uploaded file, used only for ZIP file creation
 * - <b>FileLocation:</b> full path to uploaded file. May be deleted by build()!
 * - <b>FileType:</b> MIME type of uploaded file
 * @package Models
 */
class Model_Package extends Model_Abstract
{
    /** {@inheritdoc} */
    protected $_forceValidProperties = false;

    /** {@inheritdoc} */
    protected $_propertyMap = array(
        'Name' => 'name',
        'Timestamp' => 'fileid',
        'Priority' => 'priority',
        'NumFragments' => 'fragments',
        'Size' => 'size',
        'Platform' => 'osname',
        'Comment' => 'comment',
        'EnabledId' => 'id',
        'NumNonnotified' => 'num_nonnotified',
        'NumSuccess' => 'num_success',
        'NumNotified' => 'num_notified',
        'NumError' => 'num_error',
        'Hash' => 'Hash',
        'DeployAction' => 'DeployAction',
        'ActionParam' => 'ActionParam',
        'Warn' => 'Warn',
        'WarnMessage' => 'WarnMessage',
        'WarnCountdown' => 'WarnCountdown',
        'WarnAllowAbort' => 'WarnAllowAbort',
        'WarnAllowDelay' => 'WarnAllowDelay',
        'PostInstMessage' => 'PostInstMessage',
        'MaxFragmentSize' => 'maxFragmentSize',
        'FileName' => 'fileName',
        'FileLocation' => 'fileLocation',
        'FileType' => 'fileType',
    );

    /** {@inheritdoc} */
    protected $_types = array(
        'Timestamp' => 'timestamp',
        'Priority' => 'integer',
        'NumFragments' => 'integer',
        'Size' => 'integer',
        'Comment' => 'clob',
        'EnabledId' => 'integer',
        'NumNonnotified' => 'integer',
        'NumSuccess' => 'integer',
        'NumNotified' => 'integer',
        'NumError' => 'integer',
        'Warn' => 'boolean',
        'WarnCountdown' => 'integer',
        'WarnAllowAbort' => 'boolean',
        'WarnAllowDelay' => 'boolean',
        'MaxFragmentSize' => 'integer',
    );

    /**
     * Array with error messages
     * @var array
     */
    protected $_errors = array();

    /**
     * Retrieve a property by its logical name
     *
     * Mangles platform names from raw database values to nicer abstract values.
     * @return mixed property value
     */
    public function getProperty($property, $rawValue=false)
    {
        // Treat Timestamp property before calling parent implementation to
        // avoid a PHP warning.
        if (!$rawValue and $property == 'Timestamp') {
            return new Zend_Date(parent::getProperty('Timestamp', true), Zend_Date::TIMESTAMP);
        }

        $value = parent::getProperty($property, $rawValue);
        if ($rawValue) {
            return $value;
        }

        switch ($property) {
            case 'Platform':
                $map = array(
                    'WINDOWS' => 'windows',
                    'LINUX' => 'linux',
                    'MacOSX' => 'mac',
                );
                $value = $map[$value];
                break;
            case 'WarnMessage':
            case 'WarnCountdown':
            case 'WarnAllowAbort':
            case 'WarnAllowDelay':
                if (!$this->getWarn()) {
                    $value = null;
                }
                break;
        }
        return $value;
    }

    /**
     * Set a property by its logical name
     *
     * Mangles platform names from abstract values to raw database values.
     * Raw values are accepted as well.
     */
    public function setProperty($property, $value)
    {
        if ($property == 'Platform') {
            $map = array(
                'windows' => 'WINDOWS',
                'linux' => 'LINUX',
                'mac' => 'MacOSX',
                'WINDOWS' => 'WINDOWS',
                'LINUX' => 'LINUX',
                'MacOSX' => 'MacOSX',
            );
            $value = $map[$value];
        } elseif ($property == 'Timestamp' and $value instanceof \Zend_Date) {
            // Raw value is UNIX timestamp, prevent parent from storing as ISO8601 string.
            $value = $value->get(\Zend_Date::TIMESTAMP);
        }
        parent::setProperty($property, $value);
    }

    /**
     * Return all packages matching criteria, including deployment statistics
     *
     * @param string $order Logical property to sort by. Default: null
     * @param string $direction one of [asc|desc].
     * @return \Model_Package[]
     */
    public function fetchAll($order=null, $direction='asc')
    {
        $db = Model_Database::getAdapter();

        $subqueryNonnotified = $db->select()
            ->from('devices', 'COUNT(devices.hardware_id)')
            ->joinLeft('hardware', 'devices.hardware_id=hardware.id', array())
            ->where("devices.name='DOWNLOAD'")
            ->where('devices.ivalue=download_enable.id')
            ->where('devices.tvalue IS NULL')
            ->where("hardware.deviceid != '_SYSTEMGROUP_'");
        $subquerySuccess = $db->select()
            ->from('devices', 'COUNT(hardware_id)')
            ->where("name='DOWNLOAD'")
            ->where('ivalue=download_enable.id')
            ->where("tvalue='SUCCESS'");
        $subqueryNotified = $db->select()
            ->from('devices', 'COUNT(hardware_id)')
            ->where("name='DOWNLOAD'")
            ->where('ivalue=download_enable.id')
            ->where("tvalue='NOTIFIED'");
        $subqueryError = $db->select()
            ->from('devices', 'COUNT(hardware_id)')
            ->where("name='DOWNLOAD'")
            ->where('ivalue=download_enable.id')
            ->where("tvalue LIKE 'ERR%'");

        $select = $db->select()
            ->from(
                'download_available', array(
                    'fileid',
                    'name',
                    'priority',
                    'fragments',
                    'size',
                    'osname',
                    'comment',
                )
            )
            ->joinLeftUsing(
                'download_enable', 'fileid', array(
                    'id',
                    'num_nonnotified' => new \Zend_Db_Expr("($subqueryNonnotified)"),
                    'num_success' => new \Zend_Db_Expr("($subquerySuccess)"),
                    'num_notified' => new \Zend_Db_Expr("($subqueryNotified)"),
                    'num_error' => new \Zend_Db_Expr("($subqueryError)"),
                )
            )
            ->order(self::getOrder($order, $direction, $this->_propertyMap));

        return $this->_fetchAll($select->query());
    }

    /**
     * Get all package names
     *
     * @return string[]
     */
    public function getAllNames()
    {
        return \Library\Application::getService('Database\Table\Packages')->fetchCol('name');
    }

    /**
     * Populate object with values from an array
     *
     * Unknown keys are ignored. The data is not validated!
     * @param array $data properties as keys
     */
    public function fromArray($data)
    {
        foreach ($data as $property => $value) {
            if (array_key_exists($property, $this->_propertyMap)) {
                $this->setProperty($property, $value);
            }
        }
    }

    /**
     * Populate object with values from an existing package
     *
     * Only metadata is copied, not the downloadable content. As a consequence,
     * content-related metadata (like the hash value) isn't copied neither.
     *
     * Check the return value: if this method fails, the instance may be in an
     * incostinstent state. Call {@link getErrors()} to retrieve details.
     * @param string $name Name of an existing package to be cloned.
     * @return bool TRUE if the action was successful, FALSE if an error occured.
     */
    public function fromName($name)
    {
        $this->_errors = array();
        $this->setName($name); // Set name unconditionally, even on subsequent errors

        try {
            $package = \Library\Application::getService('Model\Package\PackageManager')->getPackage($name);
            foreach ($package as $property => $value) {
                $this->setProperty($property, $value);
            }
            return true;
        } catch (\Exception $e) {
            $this->_errors[] = $e->getMessage();
            return false;
        }
    }

    /**
     * Build and activate package (metafile, package files and database entries)
     *
     * The Timestamp property will be set automatically. All other relevant
     * properties must be set to valid data before calling this.
     *
     * Warning: The file supplied by the FileLocation property may or may not
     * be deleted during the process.
     *
     * After successful build, the download URIs are tested.
     *
     * Errors can be retrieved via {@link getErrors()}. The result may also contain
     * nonfatal errors (like a failed URI test) even if build() returns TRUE.
     * If an error occurs, any files and database entries created that far
     * are cleaned up.
     *
     * @param bool $deleteSource If this is TRUE, the source file will be deleted as soon as possible.
     * @return bool TRUE if package was built and activated successfully, FALSE on error.
     */
    public function build($deleteSource)
    {
        $this->_errors = array();
        $packageManager = \Library\Application::getService('Model\Package\PackageManager');
        try {
            $this->setEnabledId($packageManager->build($this, $deleteSource));
            return true;
        } catch (\Exception $e) {
            $this->_errors[] = $e->getMessage();
            return false;
        }
    }

    /**
     * Remove all database entries and filesystem objects related to this package
     *
     * Any errors encountered will be availabe via {@link getErrors()}.
     * @return bool TRUE if everything was deleted, FALSE if an error occurred.
     */
    public function delete()
    {
        $this->_errors = array();

        if (!$this->getTimestamp()) {
            return false;
        }

        $packageManager = \Library\Application::getService('Model\Package\PackageManager');
        try {
            $packageManager->delete($this);
            return true;
        } catch (\Exception $e) {
            $this->_errors[] = $e->getMessage();
            return false;
        }
    }

    /**
     * Deploy package to all computers which had a previous package assigned
     * and deployment status in a given state
     *
     * @param Model_Package $oldPackage package to be replaced
     * @param bool $deployNonnotified Deploy to computers with status 'not notified'
     * @param bool $deploySuccess Deploy to computers with status 'success'
     * @param bool $deployNotified Deploy to computers with status 'notified'
     * @param bool $deployError Deploy to computers with status 'error'
     * @param bool $deployGroups Deploy to groups
     */
    public function updateComputers(
        Model_Package $oldPackage,
        $deployNonnotified,
        $deploySuccess,
        $deployNotified,
        $deployError,
        $deployGroups
    )
    {
        \Library\Application::getService('Model\Package\PackageManager')->updateAssignments(
            $oldPackage['EnabledId'],
            $this['EnabledId'],
            $deployNonnotified,
            $deploySuccess,
            $deployNotified,
            $deployError,
            $deployGroups
        );
    }

    /**
     * Append error message to the list.
     *
     * @param string $message untranslated message with optional {@link sprintf()
     * sprintf()}-style placeholders
     * @param mixed $args single argument or array of arguments for placeholders
     */
    protected function _setError($message, $args)
    {
        if (!is_array($args)) {
            $args = array($args);
        }
        $this->_errors[] = array($message => $args);
    }

    /**
     * Get all error messages issued by the last operation
     *
     * @return array[] Array of associative arrays (template => arg[])
     */
    public function getErrors()
    {
        return $this->_errors;
    }

    /**
     * Get number of error messages issued by the last operation
     * @return integer
     */
    public function numErrors()
    {
        return count($this->_errors);
    }
}
